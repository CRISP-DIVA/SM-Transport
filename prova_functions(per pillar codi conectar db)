import os
import pymysql
import sqlalchemy
import pandas as pd
import googlemaps
import numpy as np
from datetime import datetime

tol_lat = 0.0005
tol_lng = 0.0005
gmaps = googlemaps.Client(key='AIzaSyCYKWuRKddltQK9sAMeWTWfBOn7_wIZUSY')

def get_steps(ruta,coords,tram_types,tram_bounds):
    
    #Si el paso actual contiene subpasos
    if 'steps' in ruta.keys():
        for step in ruta['steps']:
            get_steps(step,coords,tram_types,tram_bounds)
    #Sino ya podemos coger las coord
    else:
        coords.append(np.array([ruta['start_location'],ruta['end_location']]))
        tram_types.append(ruta['travel_mode'])
        return True


def hora_tramo(request):
    
    now = datetime.now()
    data = 0
    data_arr = []
    current_time = now.strftime("%H:00:00")
    db = sqlalchemy.create_engine(
    # Equivalent URL:
    # mysql+pymysql://<db_user>:<db_pass>@/<db_name>?unix_socket=/cloudsql/<cloud_sql_instance_name>
    sqlalchemy.engine.url.URL(
        drivername="mysql+pymysql",
        username="root",
        password="ssmm2020",
        database="ssmm_transport",
        query={"unix_socket": "/cloudsql/{}".format("ssmm-transport-python:europe-west1:ssmm-transport-database")},
    ),
    # ... Specify additional properties here.
    # [START_EXCLUDE]
    # [START cloud_sql_mysql_sqlalchemy_limit]
    # Pool size is the maximum number of permanent connections to keep.
    pool_size=5,
    # Temporarily exceeds the set pool_size if no connections are available.
    max_overflow=2,
    # The total number of concurrent connections for your application will be
    # a total of pool_size and max_overflow.
    # [END cloud_sql_mysql_sqlalchemy_limit]
    # [START cloud_sql_mysql_sqlalchemy_backoff]
    # SQLAlchemy automatically uses delays between failed connection attempts,
    # but provides no arguments for configuration.
    # [END cloud_sql_mysql_sqlalchemy_backoff]
    # [START cloud_sql_mysql_sqlalchemy_timeout]
    # 'pool_timeout' is the maximum number of seconds to wait when retrieving a
    # new connection from the pool. After the specified amount of time, an
    # exception will be thrown.
    pool_timeout=30,  # 30 seconds
    # [END cloud_sql_mysql_sqlalchemy_timeout]
    # [START cloud_sql_mysql_sqlalchemy_lifetime]
    # 'pool_recycle' is the maximum number of seconds a connection can persist.
    # Connections that live longer than the specified amount of time will be
    # reestablished
    pool_recycle=1800,  # 30 minutes
    # [END cloud_sql_mysql_sqlalchemy_lifetime]
    # [END_EXCLUDE]
    )
    
    with db.connect() as conn:
        q = "SELECT * FROM rutas WHERE rutas.hora_sortida = '2000-01-01 "+current_time+"';"
        data = pd.read_sql(q,con=conn)
     
        for ruta in data.values:
            indications = gmaps.directions([ruta[1],ruta[2]],[ruta[3],ruta[4]],mode='transit',departure_time=now)
            indications = indications[0]
            
            #si walking o en transit
            tram_types = []
            #indica on comenÃ§a i on acaba el tram en la llista de coord
            tram_bounds = []
            
            coords = []
            
            for leg in indications['legs']:
                get_steps(leg,coords,tram_types,tram_bounds)
                
            coords = np.array(coords)
            #coords = coords[np.where(tram_types != 'WALKING')]
            if coords.shape[0]>10:
                n_trams = int(coords.shape[0]*0.5)
            else:
                n_trams= coords.shape[0]
                
            pre_trams = []
            for i in range(n_trams):
                pre_trams.append(coords[np.random.randint(0,coords.shape[0])])
            pre_trams=np.array(pre_trams)
            
            for coord in pre_trams:
                start= coord[0]
                end = coord[1]
                tram_lat = (end['lat']-start['lat'])/2+start['lat']
                tram_lng  =(end['lng']-start['lng'])/2+start['lng']
                
                q = "SELECT * FROM tram WHERE"
                q = q + " tram.lat > "+str(tram_lat-tol_lat)
                q = q + " AND tram.lat <= "+str(tram_lat+tol_lat)
                q = q + " AND tram.lng > "+str(tram_lng-tol_lng)
                q = q + " AND tram.lng <= "+str(tram_lng+tol_lng)+" ;"
                
                candidates = pd.read_sql(q,con=conn)
                
                if candidates.values.shape[0]>0:
                    
                    for cand in candidates.values:
                        q = "SELECT * from hores_tram WHERE hores_tram.tram_id = '"+str(cand[0])+"' AND hores_tram.hora = '"+"2000-01-01 "+current_time+"';"
                        cand_dens = conn.execute(q).fetchall()
                        
                        if (len(cand_dens)>0):
                            cand_dens = cand_dens[0]
                            cand_dens = cand_dens[2]
                            q = "UPDATE hores_tram SET hores_tram.densitat = '"+str(cand_dens+1)+"' WHERE hores_tram.tram_id = '"+str(cand[0])+"' AND hores_tram.hora = '"+"2000-01-01 "+current_time+"';"
                            conn.execute(q)
                        else:
                            id_insert = cand[0]
                            q = "INSERT INTO hores_tram (hora,densitat,tram_id) VALUES ('"+"2000-01-01 "+current_time+"','"+str(1)+"','"+str(id_insert)+"');"
                            conn.execute(q)
                else:
                    q = "INSERT INTO tram (lat,lng) VALUES ('"+str(tram_lat)+"','"+str(tram_lng)+"');"
                    conn.execute(q)
                    q = "SELECT LAST_INSERT_ID();"
                    id_insert = conn.execute(q).fetchall()
                    q = "INSERT INTO hores_tram (hora,densitat,tram_id) VALUES ('"+"2000-01-01 "+current_time+"','"+str(1)+"','"+str(id_insert[0][0])+"');"
                    conn.execute(q)